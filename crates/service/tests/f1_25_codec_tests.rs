//! Fixture-based codec tests for the EA F1 25 native UDP adapter
//!
//! Uses pre-built binary packet fixtures that match the real EA F1 25 UDP format
//! (packetFormat 2025). Fixtures were generated by scripts/gen_f1_25_fixtures.py.

use racing_wheel_service::telemetry::{TelemetryAdapter, adapters::f1_25::F1_25Adapter};

type TestResult = Result<(), Box<dyn std::error::Error>>;

const FIXTURE_CAR_TELEMETRY: &[u8] = include_bytes!("fixtures/f1_25/car_telemetry_packet.bin");
const FIXTURE_CAR_STATUS: &[u8] = include_bytes!("fixtures/f1_25/car_status_packet.bin");

/// CarTelemetry (packet_id=6) must normalize to the expected core fields.
///
/// Fixture encodes: player_index=0, speed=216 km/h, gear=7, engine_rpm=14500, drs=1
#[test]
fn test_f1_25_car_telemetry_fixture_normalizes() -> TestResult {
    let adapter = F1_25Adapter::new();
    let normalized = adapter.normalize(FIXTURE_CAR_TELEMETRY)?;

    // 216 km/h ÷ 3.6 = 60.0 m/s
    let speed = normalized.speed_ms;
    assert!(
        (speed - 60.0).abs() < 0.1,
        "expected speed ~60.0 m/s, got {speed}"
    );

    assert_eq!(normalized.gear, 7, "gear must be 7");

    let rpm = normalized.rpm;
    assert!(
        (rpm - 14500.0).abs() < 1.0,
        "expected rpm ~14500, got {rpm}"
    );

    Ok(())
}

/// CarTelemetry fixture must have DRS active flag set in extended fields.
#[test]
fn test_f1_25_car_telemetry_fixture_drs_active() -> TestResult {
    use racing_wheel_telemetry_core::TelemetryValue;
    let adapter = F1_25Adapter::new();
    let normalized = adapter.normalize(FIXTURE_CAR_TELEMETRY)?;

    let drs = normalized
        .extended
        .get("drs_active")
        .expect("drs_active must be in extended map");
    assert_eq!(
        drs,
        &TelemetryValue::Boolean(true),
        "drs_active must be true"
    );

    Ok(())
}

/// CarTelemetry fixture must include tyre pressure extended fields (in PSI).
#[test]
fn test_f1_25_car_telemetry_fixture_tyre_pressures() -> TestResult {
    use racing_wheel_telemetry_core::TelemetryValue;
    let adapter = F1_25Adapter::new();
    let normalized = adapter.normalize(FIXTURE_CAR_TELEMETRY)?;

    for key in [
        "tyre_pressure_fl_psi",
        "tyre_pressure_fr_psi",
        "tyre_pressure_rl_psi",
        "tyre_pressure_rr_psi",
    ] {
        let val = normalized
            .extended
            .get(key)
            .unwrap_or_else(|| panic!("{key} must be in extended map"));
        match val {
            TelemetryValue::Float(psi) => {
                assert!(
                    *psi > 20.0 && *psi < 35.0,
                    "{key} PSI {psi} out of expected range"
                );
            }
            other => panic!("{key} should be Float, got {other:?}"),
        }
    }

    Ok(())
}

/// CarTelemetry fixture must report throttle and brake in extended fields.
#[test]
fn test_f1_25_car_telemetry_fixture_throttle_brake() -> TestResult {
    use racing_wheel_telemetry_core::TelemetryValue;
    let adapter = F1_25Adapter::new();
    let normalized = adapter.normalize(FIXTURE_CAR_TELEMETRY)?;

    if let Some(TelemetryValue::Float(throttle)) = normalized.extended.get("throttle") {
        assert!(
            *throttle > 0.9 && *throttle <= 1.0,
            "expected throttle ~0.95, got {throttle}"
        );
    } else {
        panic!("throttle must be Float in extended map");
    }

    if let Some(TelemetryValue::Float(brake)) = normalized.extended.get("brake") {
        assert!(*brake < 0.01, "expected brake ~0.0, got {brake}");
    } else {
        panic!("brake must be Float in extended map");
    }

    Ok(())
}

/// CarStatus (packet_id=7) alone must be rejected by normalize() — it requires
/// a CarTelemetry packet to produce a complete NormalizedTelemetry.
#[test]
fn test_f1_25_car_status_alone_is_rejected() {
    let adapter = F1_25Adapter::new();
    let result = adapter.normalize(FIXTURE_CAR_STATUS);
    assert!(
        result.is_err(),
        "CarStatus packet alone should not yield NormalizedTelemetry without CarTelemetry state"
    );
}

/// Truncated packet must be rejected gracefully (no panic).
#[test]
fn test_f1_25_truncated_packet_is_rejected() {
    let adapter = F1_25Adapter::new();
    // Only the first 20 bytes (less than the 29-byte header)
    let truncated = &FIXTURE_CAR_TELEMETRY[..20];
    let result = adapter.normalize(truncated);
    assert!(result.is_err(), "truncated packet must return an error");
}

/// Empty packet must be rejected gracefully (no panic).
#[test]
fn test_f1_25_empty_packet_is_rejected() {
    let adapter = F1_25Adapter::new();
    let result = adapter.normalize(&[]);
    assert!(result.is_err(), "empty packet must return an error");
}

/// Packet with wrong packetFormat (not 2025) must be rejected.
#[test]
fn test_f1_25_wrong_format_rejected() {
    let adapter = F1_25Adapter::new();
    let mut bad_packet = FIXTURE_CAR_TELEMETRY.to_vec();
    // Overwrite bytes 0-1 (packetFormat u16 little-endian) with 2024
    let bad_format: u16 = 2024;
    bad_packet[0..2].copy_from_slice(&bad_format.to_le_bytes());
    let result = adapter.normalize(&bad_packet);
    assert!(result.is_err(), "packet with format 2024 must be rejected");
}
